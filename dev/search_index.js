var documenterSearchIndex = {"docs":
[{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"EditURL = \"<unknown>/src/Examples/alphashape/alphashape.jl\"","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"using BioMakie\nusing GLMakie\nusing GLMakie: Slider\nusing SplitApplyCombine\nusing GeometryBasics\nusing BioStructures","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"SciPy and NumPy are required for this alpha shape algorithm. They need to be installed in your Conda/Python environment.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"using PyCall\nusing Conda\n\nscipy = pyimport_conda(\"scipy\", \"scipy\")\nnp = pyimport_conda(\"numpy\", \"numpy\")\ncollections = pyimport_conda(\"collections\", \"collections\")","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Function to shift array indices by 1, since Python is base 0 and Julia is base 1.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"indexshift(idxs) = (idxs).+=1","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Define the alpha shape algorithm.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"py\"\"\"\n    from scipy.spatial import Delaunay\n    import numpy as np\n    from collections import defaultdict\n\n    def alpha_shape_3D(pos, alpha):\n        tetra = Delaunay(pos)\n        tetrapos = np.take(pos,tetra.vertices,axis=0)\n        normsq = np.sum(tetrapos**2,axis=2)[:,:,None]\n        ones = np.ones((tetrapos.shape[0],tetrapos.shape[1],1))\n        a = np.linalg.det(np.concatenate((tetrapos,ones),axis=2))\n        Dx = np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[1,2]],ones),axis=2))\n        Dy = -np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[0,2]],ones),axis=2))\n        Dz = np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[0,1]],ones),axis=2))\n        c = np.linalg.det(np.concatenate((normsq,tetrapos),axis=2))\n        r = np.sqrt(Dx**2+Dy**2+Dz**2-4*a*c)/(2*np.abs(a))\n        tetras = tetra.vertices[r<alpha,:]\n        TriComb = np.array([(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)])\n        Triangles = tetras[:,TriComb].reshape(-1,3)\n        Triangles = np.sort(Triangles,axis=1)\n        TrianglesDict = defaultdict(int)\n        for tri in Triangles:\n            TrianglesDict[tuple(tri)] += 1\n        Triangles=np.array([tri for tri in TrianglesDict if TrianglesDict[tri] ==1])\n        EdgeComb=np.array([(0, 1), (0, 2), (1, 2)])\n        Edges=Triangles[:,EdgeComb].reshape(-1,2)\n        Edges=np.sort(Edges,axis=1)\n        Edges=np.unique(Edges,axis=0)\n        Vertices = np.unique(Edges)\n        return Vertices,Edges,Triangles\n    \"\"\"","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Define a function to get the alpha shape of a set of coordinates.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"function getalphashape(coords::Matrix, alpha::T) where {T<:Real}\n    verts,edges,tris = py\"alpha_shape_3D($(coords),$(alpha))\"\n    return [indexshift(verts),indexshift(edges),indexshift(tris)]\nend","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Define a function to get points from spheres at a given radius around coordinates.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"function getspherepoints(cords::Matrix, radius::Real)\n\tpnts = [GeometryBasics.Point{3,Float64}(cords[i,:]) for i in 1:size(cords,1)] |> Observable\n\tspheres = GeometryBasics.Point{3,Float64}[]\n\n\t@sync(@async lift(pnts) do p\n\t\tfor i in 1:size(p,1)\n\t\t\tsp = GeometryBasics.decompose(GeometryBasics.Point{3,Float64},GeometryBasics.Sphere(p[i],radius),4) |> unique\n\t\t\tfor ii in 1:size(sp,1)\n\t\t\t\tpush!(spheres,sp[ii])\n\t\t\tend\n\t\tend\n\tend)\n\n\treturn [[spheres[i].data...] for i in 1:size(spheres,1)] |> combinedims |> transpose |> collect\nend","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Define a function to get line segments from a set of coordinates.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"function linesegs(arr::AbstractArray{T,3}) where T<:AbstractFloat\n    new_arr::AbstractArray{Point3f0} = []\n    @sync(@async begin\n        for i in 1:size(arr,1)\n            push!(new_arr, Makie.Point3f0(arr[i,1,:]))\n            push!(new_arr, Makie.Point3f0(arr[i,2,:]))\n        end\n    end)\n    return new_arr |> combinedims |> transpose |> collect\nend","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Load the structure with BioStructures.jl and get a coordinates Observable.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"struc = retrievepdb(\"2vb1\")\natms = collectatoms(struc, standardselector) |> Observable\ncords = @lift coordarray($atms)' |> collect","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Make the Figure and Layout","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"fig = Figure(resolution = (800,600))\nlayout = fig[1,1] = GridLayout(10, 9)","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Add text and interactive elements. It can be helpful to run this line by line to see what is happening.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"strucname = struc.name[1:4]\nsc_scene = layout[1:10,1:6] = LScene(fig; show_axis = false)\nstructxt = layout[1,7:8] = Label(fig, text = \"Structure ID:  $(strucname)\", fontsize = 35)\nalpha1 = layout[5,7:9] = Slider(fig, range = 1.5:0.01:9.0, startvalue = 2.5)\nalphatxt1 = lift(alpha1.value) do s1; string(\"alpha = \", round(s1, sigdigits = 2)); end\nalphatext = layout[4,7:9] = Label(fig, text = alphatxt1, fontsize = 22)\nalphaval = alpha1.value\nradii1 = layout[7,7:9] = Slider(fig, range = 1.5:0.01:9.0, startvalue = 2.5)\nradiixt1 = lift(radii1.value) do s1; string(\"atom radius = \", round(s1, sigdigits = 2)); end\nradiitext = layout[6,7:9] = Label(fig, text = radiixt1, fontsize = 22)\nradiival = radii1.value","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Get the alpha shape of the structure.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"spnts = @lift getspherepoints($cords,$radiival)\nproteinshape = @lift let pnts = $spnts; getalphashape(pnts,$alphaval); end\nalphaverts = @lift $spnts[$(proteinshape)[1],:]\nalphaedges = @lift $spnts[$(proteinshape)[2],:] |> linesegs","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Finally, plot the shape. Moving the sliders will update the plot, but it is slow. You may want to click on the slider rather than dragging it. Speed may be improved in the future.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"linesegments!(sc_scene, alphaedges, color = :gray, transparency = true)","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Optional/additional stuff","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"To show where the atoms are run the following line.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"meshscatter!(sc_scene, cords, markersize = 0.4, color = :blue)","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"To show the alpha shape vertices run the following line.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"meshscatter!(sc_scene, alphaverts, markersize = 0.4, color = :green)","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Get the surface area of the alpha shape.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"using Meshes","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Define a function to get the surface area of a set of coordinates and connectivity. The surface area changes when the alpha value or atom radius is changed.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"function surfacearea(coordinates, connectivity)\n    totalarea = 0.0\n    @sync(@async begin\n        for i = 1:size(connectivity,1)\n            totalarea += measure(Ngon(Meshes.Point3.(coordinates[connectivity[i,1],:],\n                            coordinates[connectivity[i,2],:], coordinates[connectivity[i,3],:])))\n        end\n    end)\n    return totalarea\nend\nsurfarea = @lift surfacearea($spnts, $(proteinshape)[3])\nsurfatext = layout[2,7:9] = Label(fig, text = lift(X->string(\"surface area = \", round(Int64, X), \"  Å²\"), surfarea), fontsize = 22)","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"Save the figure as a png file.","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"save(\"alphashape.png\", fig)","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Examples/alphashape/alphashape/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"<unknown>/src/index.jl\"","category":"page"},{"location":"#BioMakie.jl","page":"Home","title":"BioMakie.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides plotting functions for protein structures, multiple sequence alignments, and some other related plots like protein structure contact maps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So far, plotting methods exist for packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BioStructures.jl\nMIToS.jl\nFastaIO.jl\nFASTX.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other packages with plotting methods in development:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MolecularGraph.jl\nProtoSyn.jl","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package mode by pressing ] and run add BioMakie.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main plotting functions are plotstruc and plotmsa, along with their mutating versions, plotstruc! and plotmsa!. The mutating functions allow the user to add multiple plots to the same Figure, using grid positions.","category":"page"},{"location":"#Structure","page":"Home","title":"Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are different representations for protein structures, including \"ball and stick\" (:ballandstick), \"covalent\" (:covalent), and \"space filling\" (:spacefilling). The default Makie backend is GLMakie.jl, but some of the functions work with WGLMakie.","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd(\"docs/src/assets/\") # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie: lift, @lift, Observable # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BioMakie\nusing GLMakie\nusing BioStructures\nstruc = retrievepdb(\"2vb1\") |> Observable\n# or\nstruc = read(\"2vb1.pdb\", BioStructures.PDB) |> Observable","category":"page"},{"location":"","page":"Home","title":"Home","text":"fig = Figure()\nplotstruc!(fig, struc; plottype = :ballandstick, gridposition = (1,1), atomcolors = aquacolors)\nplotstruc!(fig, struc; plottype = :covalent, gridposition = (1,2))\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: strucs)","category":"page"},{"location":"#Multiple-Sequence-Alignments","page":"Home","title":"Multiple Sequence Alignments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple Sequence Alignments (MSAs) are plotted using a matrix of residue letters, and a matrix of values for the heatmap colors. If only a matrix of letters is provided as input, colors will be automatic. MSA objects from MIToS have specific support, as well as Fasta files loaded with FastaIO.jl or FASTX.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To view a multiple sequence alignment, use the plotmsa or plotmsa! function with a Pfam MSA or fasta file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FASTX\nreader = open(FASTX.FASTA.Reader, \"PF00062_full.fasta\")\nmsa = [reader...] |> Observable\nclose(reader)\n# or\nusing MIToS\nusing MIToS.MSA\nmsa = MIToS.MSA.read(\"pf00062.stockholm.gz\", Stockholm)\n\nfig = plotmsa(msa; colorscheme = :tableau_blue_green)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: MSA)","category":"page"},{"location":"#Additional-examples","page":"Home","title":"Additional examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Alpha shapes can be used to visualize the surface of a protein structure","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: alphashape)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/#BioMakie-API","page":"API","title":"BioMakie API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [BioMakie]","category":"page"},{"location":"API/#BioMakie.atomcolors-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.atomcolors","text":"atomcolors( atoms )\n\nGet a Vector of colors for the atoms. To see all default element and amino acid colorschemes, use getbiocolors(). Keyword argument colors takes a Dict which maps element to color. (\"C\" => :red)\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\ncolors –- elecolors | Options - elecolors, aquacolors\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.atomradii-Union{Tuple{Vector{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.atomradii","text":"atomradii( atoms )\n\nCollect atom radii based on element for plotting.\n\nKeyword Arguments:\n\nradiustype –- :ballandstick | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.atomradius-Tuple{T} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.atomradius","text":"atomradius( atom )\n\nCollect atom radius based on element for plotting.\n\nKeyword Arguments:\n\nradiustype –- :ballandstick | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.atomsizes-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.atomsizes","text":"atomsizes( atms )\n\nGet a Vector of sizes for the atoms from a BioStructures.StructuralElementOrList.\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nradiustype –- :ballandstick | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.backbonebonds-Tuple{BioStructures.Chain}","page":"API","title":"BioMakie.backbonebonds","text":"backbonebonds( chn::BioStructures.Chain ) -> BitMatrix\n\nReturns a matrix of backbone bonds in chn, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nKeyword Arguments:\n\ncutoff –––––- 1.6\t\t# distance cutoff for bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.bondshape-Union{Tuple{Tuple{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.bondshape","text":"bondshape( twoatoms )\nbondshape( twopoints )\n\nReturns a (mesh) cylinder between two atoms or atomic coordinates.\n\nKeyword Arguments:\n\nbondwidth ––––––- 0.2\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.bondshapes-Tuple{BioStructures.Chain}","page":"API","title":"BioMakie.bondshapes","text":"bondshapes( structure )\nbondshapes( residues )\nbondshapes( coordinates )\nbondshapes( structure, bondmatrix )\nbondshapes( residues, bondmatrix )\nbondshapes( coordinates, bondmatrix )\n\nReturns a (mesh) cylinder between two atoms or points.\n\nKeyword Arguments:\n\nalgo ––––––––– :knowledgebased | :distance, :covalent\t# unless bondmatrix is given\ndistance ––––––– 1.9\t\t\t\t\t\t\t\t\t\t# unless bondmatrix is given\nbondwidth ––––––- 0.2\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.covalentbonds-Union{Tuple{Vector{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.covalentbonds","text":"covalentbonds( atms ) -> BitMatrix\n\nReturns a matrix of all bonds in atms, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nextradistance –– 0.14  # fudge factor for better inclusion\nH –––––––– true  # include bonds with hydrogen atoms\ndisulfides –––- false # include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.distancebonds-Union{Tuple{Vector{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.distancebonds","text":"distancebonds( atms ) -> BitMatrix\n\nReturns a matrix of all bonds in atms, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\ncutoff –––––- 1.9   # distance cutoff for bonds between heavy atoms\nhydrogencutoff –- 1.14  # distance cutoff for bonds with hydrogen atoms\nH –––––––– true  # include bonds with hydrogen atoms\ndisulfides –––- false # include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.firstlabel-Tuple{Function}","page":"API","title":"BioMakie.firstlabel","text":"firstlabel( inspectorfunc::Function )\nfirstlabel( inspectorfunc::Observable{T} ) where {T<:Function}\n\nShow an example of the inspector label function looks like. The position p will not be available to this function, so it will be set to nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getbonds-Tuple{BioStructures.Chain, Vararg{Any}}","page":"API","title":"BioMakie.getbonds","text":"getbonds( chn::BioStructures.Chain, selectors... ) -> BitMatrix\ngetbonds( modl::BioStructures.Model, selectors... ) -> BitMatrix\ngetbonds( struc::BioStructures.ProteinStructure, selectors... ) -> BitMatrix\n\nReturns a matrix of all bonds in chn, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nalgo ––––––- :knowledgebased \t# (:distance, :covalent) algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\ndisulfides –––- false\t\t\t\t# include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getbonds-Tuple{Vector{MIToS.PDB.PDBResidue}}","page":"API","title":"BioMakie.getbonds","text":"getbonds( residues ) -> BitMatrix\n\nReturns a matrix of all bonds in residues, where Mat[i,j] = 1 if atoms i and j are bonded.\n\nKeyword Arguments:\n\nalgo ––––––- :knowledgebased \t# (:distance, :covalent) algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\ndisulfides –––- false\t\t\t\t# include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getinspectorlabel-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.getinspectorlabel","text":"getinspectorlabel( structure )\ngetinspectorlabel( residues )\ngetinspectorlabel( atom )\n\nGet the inspector label function for plotting a 'StructuralElementOrList'.\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.msavalues","page":"API","title":"BioMakie.msavalues","text":"msavalues( msa::AbstractMatrix, resdict::AbstractDict )::Matrix{Real}\n\nReturns a matrix of numbers according to the given dictionary, where keys are residue letters and values are numbers. This matrix is used as input for plotmsa for the heatmap colors.\n\nDefault values for residue letters are from Kidera Factor values.  kf 2 is Kidera Factor 2 (size/volume-related). The KF dictionary is in utils.jl.\n\n\n\n\n\n","category":"function"},{"location":"API/#BioMakie.plotmsa!-Union{Tuple{T}, Tuple{Figure, T}} where T<:Union{Vector{Tuple{String, String}}, Vector{FASTX.FASTA.Record}, MIToS.MSA.AbstractMultipleSequenceAlignment}","page":"API","title":"BioMakie.plotmsa!","text":"plotmsa!( fig, msa )\n\nPlot a multiple sequence alignment (MSA) into a Figure. \n\nExample\n\nfig = Figure(resolution = (1100, 400))\n\nplotmsa!( fig::Figure, msa::T; kwargs... ) where {T<:Union{MSA.AbstractMultipleSequenceAlignment,\n\t\t\t\t\t\t\t\t\t\t\t   Vector{Tuple{String,String}},\n\t\t\t\t\t\t\t\t\t\t\t   Vector{FASTX.FASTA.Record}}}\n\nKeyword Arguments:\n\nxlabels –––- {1:height}\nylabels –––- {1:width}\nsheetsize ––- [40,20]\ngridposition – (1,1)\nmarkersize –– 12\ncolorscheme –- :buda\nmarkercolor –- :black\nkwargs...   \t\t\t\t\t# forwarded to scatter plot\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plotmsa-Tuple{Any}","page":"API","title":"BioMakie.plotmsa","text":"plotmsa( msa )\nplotmsa( plotdata )\n\nPlot a multiple sequence alignment (MSA). Returns a Figure, or a Figure and Observables for interaction. \n\nExamples\n\ndownloadpfam(\"PF00062\")\nmsa = MIToS.MSA.read(\"PF00062.stockholm.gz\", Stockholm, \n\t\t\t\t\tgeneratemapping =true, useidcoordinates=true)\n\nplotmsa( msa; kwargs... )\n\nKeyword Arguments:\n\nresolution –––– (1100, 400)\nsheetsize ––––- [40,20]\ngridposition ––– (1,1)\ncolorscheme –––- :viridis\nresdict –––––- kideradict    # Dictionary of values (::Dict{String,Float}, \"Y\" => 1.48) for heatmap.\nkf –––––––– 2             # If resdict == kideradict, this is the Kidera Factor. KF2 is size/volume-related.\nkwargs...    \t\t\t\t\t\t# forwarded to scatter plot\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plotstruc!-Union{Tuple{T}, Tuple{Figure, T}} where T<:Union{Vector{MIToS.PDB.PDBAtom}, Vector{MIToS.PDB.PDBResidue}, OrderedCollections.OrderedDict, BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.plotstruc!","text":"plotstruc!( fig, structure )\nplotstruc!( gridposition, structure )\nplotstruc!( fig, plotdata )\nplotstruc!( gridposition, plotdata )\n\nPlot a protein structure(/chain/residues/atoms) into a Figure. \n\nExamples\n\nfig = Figure()\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"2vb1\")\nstruc = MIToS.PDB.read(pdbfile, PDBML) |> Observable\nstrucplot = plotstruc!(fig, struc)\n\nchain_A = @residues struc model \"1\" chain \"A\" group \"ATOM\" residue All\nstrucplot = plotstruc!(fig, chain_A)\n\nchnatms = @atoms struc model \"1\" chain \"A\" group \"ATOM\" residue All atom All\nstrucplot = plotstruc!(fig, chnatms)\n-------------------------\nusing BioStructures\n\nstruc = retrievepdb(\"2vb1\", dir = \"data/\") |> Observable\nstrucplot = plotstruc!(fig, struc)\n\nstruc = read(\"data/2vb1_mutant1.pdb\", BioStructures.PDB) |> Observable\nstrucplot = plotstruc!(fig, struc)\n\nchain_A = retrievepdb(\"2hhb\", dir = \"data/\")[\"A\"] |> Observable\nstrucplot = plotstruc!(fig, chain_A)\n\nKeyword Arguments:\n\nresolution ––- (800,600)\ngridposition –- (1,1)  # if an MSA is already plotted, (2,1:3) works well\nplottype –––- :ballandstick, :covalent, or :spacefilling\natomcolors ––- elecolors, others in getbiocolors(), or provide a Dict like: \"N\" => :blue\nmarkersize ––- 0.0\nmarkerscale –– 1.0\nbondtype –––- :knowledgebased, :covalent, or :distance\ndistance –––- 1.9  # distance cutoff for covalent bonds\ninspectorlabel - :default, or define your own function like: (self, i, p) -> \"atom: ... coords: ...\"\nwater ––––– false  # show water molecules\nkwargs... ––– keyword arguments passed to the atom meshscatter\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plotstruc-Tuple{Any}","page":"API","title":"BioMakie.plotstruc","text":"plotstruc( structure )\nplotstruc( residues )\nplotstruc( plotdata )\n\nCreate and return a Makie Figure for a protein structural element. \n\nExamples\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"2vb1\")\nstruc = MIToS.PDB.read(pdbfile, PDBML) |> Observable\nstrucplot = plotstruc(struc)\n\nchain_A = @residues struc model \"1\" chain \"A\" group \"ATOM\" residue All\nstrucplot = plotstruc(chain_A)\n\nchnatms = @atoms struc model \"1\" chain \"A\" group \"ATOM\" residue All atom All\nstrucplot = plotstruc(chnatms)\n-------------------------\nusing BioStructures\n\nstruc = retrievepdb(\"2vb1\", dir = \"data/\") |> Observable\nstrucplot = plotstruc(struc)\n\nstruc = read(\"data/2vb1_mutant1.pdb\", BioStructures.PDB) |> Observable\nstrucplot = plotstruc(struc)\n\nchain_A = retrievepdb(\"2hhb\", dir = \"data/\")[\"A\"] |> Observable\nstrucplot = plotstruc(chain_A)\n\nKeyword Arguments:\n\nresolution ––- (800,600)\ngridposition –- (1,1)  # if an MSA is already plotted, (2,1:3) works well\nplottype –––- :ballandstick, :covalent, or :spacefilling\natomcolors ––- elecolors, others in getbiocolors(), or provide a Dict like: \"N\" => :blue\nmarkersize ––- 0.0\nmarkerscale –– 1.0\nbondtype –––- :knowledgebased, :covalent, or :distance\ndistance –––- 1.9  # distance cutoff for covalent bonds\ninspectorlabel - :default, or define your own function like: (self, i, p) -> \"atom: ... coords: ...\"\nwater ––––– false  # show water molecules\nkwargs... ––– keyword arguments passed to the atom meshscatter\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plottingdata-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.plottingdata","text":"plottingdata( structure )\nplottingdata( residues )\nplottingdata( atoms )\n\nThis function returns an OrderedDict of the main data used for plotting.  This function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom. By default the kwarg 'water' is set to false, so water molecules are not included.\n\nReturns:\n\nOrderedDict(\"atoms\" => ..., \n            \"coords\" => ..., \n            \"colors\" => ...,\n            \"sizes\" => ...,\n            \"bonds\" => ...)\n\nKeyword Arguments:\n\ncolors –––- elecolors      | Options - elecolors, aquacolors, shapelycolors, maecolors\nradiustype –- :ballandstick  | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\nwater –––– false          | Options - true, false\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plottingdata-Tuple{MIToS.MSA.AbstractMultipleSequenceAlignment}","page":"API","title":"BioMakie.plottingdata","text":"plottingdata( msa )\n\nCollects data for plotting (residue string matrix, matrix heatmap values,  x labels, and y labels) from a multiple sequence alignment (MSA) object. \n\nThe MSA object can be a: \n\nAbstractMultipleSequenceAlignment from MIToS.MSA, \nvector of tuples 'Vector{Tuple{String,String}}' from FastaIO, \nvector of FASTA records 'Vector{FASTX.FASTA.Record}' from FASTX.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.rescolors-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.rescolors","text":"rescolors( residues )\n\nGet a Vector of colors for the atoms. To see all default element and amino acid colorschemes, use getbiocolors(). Keyword argument colors takes a Dict which maps residue to color. (\"C\" => :red)\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\ncolors –- elecolors | Options - elecolors, aquacolors, shapelycolors, maecolors\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.sidechainbonds-Tuple{BioStructures.AbstractResidue, Vararg{Any}}","page":"API","title":"BioMakie.sidechainbonds","text":"sidechainbonds( res::BioStructures.AbstractResidue, selectors... ) -> BitMatrix\n\nReturns a matrix of sidechain bonds in res, where Mat[i,j] = 1 if atoms i and j are bonded.\n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nalgo ––––––- :knowledgebased \t# (:distance, :covalent) algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\n\n\n\n\n\n","category":"method"}]
}
