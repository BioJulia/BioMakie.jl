var documenterSearchIndex = {"docs":
[{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"EditURL = \"https://github.com/kool7d/BioMakie.jl/blob/dev/docs/src/msaselection.md\"","category":"page"},{"location":"msaselection/#MSA-Selection","page":"MSA Selection","title":"MSA Selection","text":"","category":"section"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"In this demo we plot an MSA and allow the user to select a residue. The selected residue is highlighted in the MSA and the amino acid frequencies are plotted on the right.","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"using BioMakie\nusing MIToS\nusing MIToS.MSA, MIToS.Pfam\nusing GLMakie\nusing Lazy","category":"page"},{"location":"msaselection/#Acquire-the-data","page":"MSA Selection","title":"Acquire the data","text":"","category":"section"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"Use MIToS to download a Pfam MSA, then prepare the plotting data.","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"downloadpfam(\"pf00062\")\nmsa1 = MIToS.MSA.read(\"pf00062.stockholm.gz\",Stockholm)\nmsa2 = Observable(msa1)\nplotdata = plottingdata(msa2)","category":"page"},{"location":"msaselection/#Plot-the-MSA","page":"MSA Selection","title":"Plot the MSA","text":"","category":"section"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"We make the figure resolution a bit bigger than default because we want to add in the frequency plot on the right.","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"fig = Figure(resolution = (1400,400))\nmsa = plotmsa!(fig, plotdata)","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"(Image: msa)","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"Prepare column data for the frequency plot. In this example we color based on hydrophobicity value from a set of physicochemical property values, the Kidera factors.","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"coldata = lift(plotdata[:selected]) do sel\n    try\n        plotdata[:matrix][][:,parse(Int,sel)]\n    catch\n        [\"-\" for i in 1:size(plotdata[:matrix][])[1]]\n    end\nend\nallaas = [  \"R\", \"M\", \"N\", \"E\", \"F\",\n            \"I\", \"D\", \"L\", \"A\", \"Q\",\n            \"G\", \"C\", \"W\", \"Y\", \"K\",\n            \"P\", \"T\", \"S\", \"V\", \"H\",\n            \"X\", \"-\"]\nsortaas = sortperm(allaas)\nnew_aalabels = allaas[sortaas]\nhydrophobicities = [BioMakie.kideradict[new_aalabels[i]][2] for i in 1:length(new_aalabels)]","category":"page"},{"location":"msaselection/#Create-the-Observables-to-sync-the-data-between-the-MSA-and-the-frequency-plot.","page":"MSA Selection","title":"Create the Observables to sync the data between the MSA and the frequency plot.","text":"","category":"section"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"Utilize observables to update the frequency plot when the user selects a residue.","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"countmap1 = @lift frequencies($coldata) |> sort\naas = @lift collect(keys($countmap1))\nfreqs = lift(aas) do a\n    collect(values(countmap1[]))\nend\nmissingaas = @lift setdiff(allaas,$aas) |> sort\nmissingfreqs = @lift zeros(length($missingaas))\nperm1 = @lift sortperm([$aas; $missingaas])\naafreqs = @lift ([freqs[];$missingfreqs])[$perm1]\naafreqspercent = @lift $aafreqs ./ sum($aafreqs) .* 100\nnew_aafreqs = @lift $aafreqspercent[sortaas]","category":"page"},{"location":"msaselection/#Create-the-frequency-plot","page":"MSA Selection","title":"Create the frequency plot","text":"","category":"section"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"The keyword arguments for the Axis and barplot are adjusted to make it look nice.","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"ax = Axis(fig[1,4], xticklabelsize = 16, yticks = (0:10:100), yticklabelsize = 20,\n            title = \"Amino Acid Percentages\",\n            titlesize = 18, xticks = (1:22,new_aalabels)\n)\nbp = barplot!(ax, 1:22, aafreqspercent; color = hydrophobicities, strokewidth = 1,\n                xtickrange=1:22, xticklabels=new_aalabels\n)\nylims!(ax, (0, 100))\nxlims!(ax, (0, 23))","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"(Image: msaselection)","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"","category":"page"},{"location":"msaselection/","page":"MSA Selection","title":"MSA Selection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"EditURL = \"https://github.com/kool7d/BioMakie.jl/blob/dev/docs/src/mutation.md\"","category":"page"},{"location":"mutation/#ProtoSyn-Protein-Mutation","page":"Mutation","title":"ProtoSyn Protein Mutation","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"In this demo we can use ProtoSyn to mutate amino acids. Different rotamers can be selected for the mutated residue. To use ProtoSyn you currently have to use a workaround.","category":"page"},{"location":"mutation/#Load-BioMakie-and-ProtoSyn","page":"Mutation","title":"Load BioMakie and ProtoSyn","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"Download the protosyn source code from the src directory of BioMakie and include it. This should install a few packages (SplitApplyCombine, Colors, Meshes, GeometryBasics, OrderedCollections, Distances) and then import ProtoSyn.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"using BioMakie\nusing GLMakie\n\nBioMakie.getprotosyn()\ninclude(\"protosyn.jl\")","category":"page"},{"location":"mutation/#Prepare-the-structure","page":"Mutation","title":"Prepare the structure","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"To simplify things, we will load a structure with BioStructures and save chain \"A\" as a PDB file. Then we will load the PDB file with ProtoSyn.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"using BioStructures\nstruc = retrievepdb(\"2vb1\")\nchn = collectresidues(struc[1][\"A\"], standardselector)\nwritepdb(\"2vb1x.pdb\", chn)\n\npose = ProtoSyn.Peptides.load(\"2vb1x.pdb\"; bonds_by_distance=true) |> Observable","category":"page"},{"location":"mutation/#Get-plotting-data-for-the-Pose-and-plot-it","page":"Mutation","title":"Get plotting data for the Pose and plot it","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"pdata = plottingdata(pose)\nfig = Figure()\n_plotstruc!(fig, pdata)","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"(Image: wildtypearg)","category":"page"},{"location":"mutation/#Prepare-the-structure-2","page":"Mutation","title":"Prepare the structure","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"We can use diagnose to get an idea of what is missing and of inconsistencies in the structure.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"ProtoSyn.Peptides.diagnose(pose[])","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"We have several issues, including charges, naming, and caps, which are the terminal hydrogens. We can use the following functions to address these issues. First we load the library of amino acids, to get the Peptide/protein-specific data, instead of the default generic data.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"res_lib = ProtoSyn.load_grammar_from_file(ProtoSyn.resource_dir*\"/Peptides/grammars.yml\", \"default\")\nProtoSyn.Peptides.cap!(pose[])\nProtoSyn.Peptides.assign_default_atom_names!(pose[])\nProtoSyn.sort_atoms_by_graph!(pose[])\nProtoSyn.Peptides.Calculators.Electrostatics.assign_default_charges!(pose[], res_lib)\n\nProtoSyn.Peptides.diagnose(pose[])","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"Now the issues should say OK, except for the atom-level graph. We can ignore this for now. This fixpose! function below may be convenient for syncing and correcting the structure after making changes. Using pose[] = pose[] can force Makie to update the pose/figure.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"function fixpose!(pose::Observable; res_lib=ProtoSyn.load_grammar_from_file(ProtoSyn.resource_dir*\"/Peptides/grammars.yml\", \"default\"))\n    ProtoSyn.Peptides.cap!(pose[])\n    ProtoSyn.Peptides.assign_default_atom_names!(pose[])\n    ProtoSyn.sort_atoms_by_graph!(pose[])\n    ProtoSyn.Calculators.Electrostatics.assign_default_charges!(pose[],res_lib)\n    ProtoSyn.Peptides.sync!(pose[])\n    pose[] = pose[]\nend","category":"page"},{"location":"mutation/#Mutate-the-structure","page":"Mutation","title":"Mutate the structure","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"Get information about a residue. In this example we will use residue 128 because it is easy to find on the structure. The long side chain of this arginine extends outward the furthest.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"pose[].graph[1][128]","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"Next lets try mutating it to tyrosine. We can use the mutate! function to do this. Combine it with fixpose! to get the updated structure. You should see the side chain change into the phenol ring of tyrosine.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"ProtoSyn.Peptides.mutate!(pose[], pose[].graph[1][128], res_lib, seq\"Y\")\nfixpose!(pose)","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"(Image: mutanttyr)","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"To choose different rotamers/orientations, we can use the rotamer library. ProtoSyn provides a stack of the most likely rotamers based on the dihedral angles of the residue.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"rot_lib = ProtoSyn.Peptides.load_dunbrack()\nphi = ProtoSyn.getdihedral(pose[].state, ProtoSyn.Peptides.phi(pose[].graph[1][128]))\npsi = ProtoSyn.getdihedral(pose[].state, ProtoSyn.Peptides.psi(pose[].graph[1][128]))\nstack = rot_lib[\"TYR\"][phi, psi]\n\nProtoSyn.Peptides.apply!(pose[].state, stack[3], pose[].graph[1][128])\nfixpose!(pose)","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"(Image: mutanttyrrotamer)","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"EditURL = \"https://github.com/BioJulia/BioMakie.jl/blob/dev/docs/src/alphashape.md\"","category":"page"},{"location":"alphashape/#Alpha-shape-of-a-protein","page":"Alpha Shape","title":"Alpha shape of a protein","text":"","category":"section"},{"location":"alphashape/#Copy-pastable-code-(if-you-have-PyCall-NumPy-SciPy-set-up)","page":"Alpha Shape","title":"Copy-pastable code (if you have PyCall + NumPy + SciPy set up)","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"using BioMakie\nusing GLMakie\nusing GLMakie: Slider\nusing SplitApplyCombine\nusing GeometryBasics\nusing BioStructures\nusing PyCall\nusing Conda\nscipy = pyimport(\"scipy\")\nnp = pyimport(\"numpy\")\ncollections = pyimport(\"collections\")\npy\"\"\"\n    from scipy.spatial import Delaunay\n    import numpy as np\n    from collections import defaultdict\n    def alpha_shape_3D(pos, alpha):\n        tetra = Delaunay(pos)\n        tetrapos = np.take(pos,tetra.simplices,axis=0)\n        normsq = np.sum(tetrapos**2,axis=2)[:,:,None]\n        ones = np.ones((tetrapos.shape[0],tetrapos.shape[1],1))\n        a = np.linalg.det(np.concatenate((tetrapos,ones),axis=2))\n        Dx = np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[1,2]],ones),axis=2))\n        Dy = -np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[0,2]],ones),axis=2))\n        Dz = np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[0,1]],ones),axis=2))\n        c = np.linalg.det(np.concatenate((normsq,tetrapos),axis=2))\n        r = np.sqrt(Dx**2+Dy**2+Dz**2-4*a*c)/(2*np.abs(a))\n        tetras = tetra.simplices[r<alpha,:]\n        TriComb = np.array([(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)])\n        Triangles = tetras[:,TriComb].reshape(-1,3)\n        Triangles = np.sort(Triangles,axis=1)\n        TrianglesDict = defaultdict(int)\n        for tri in Triangles:\n            TrianglesDict[tuple(tri)] += 1\n        Triangles=np.array([tri for tri in TrianglesDict if TrianglesDict[tri] ==1])\n        EdgeComb=np.array([(0, 1), (0, 2), (1, 2)])\n        Edges=Triangles[:,EdgeComb].reshape(-1,2)\n        Edges=np.sort(Edges,axis=1)\n        Edges=np.unique(Edges,axis=0)\n        Vertices = np.unique(Edges)\n        return Vertices,Edges,Triangles\n    \"\"\"\nindexshift(idxs) = (idxs).+=1\nfunction getalphashape(coords::Matrix, alpha::T) where {T<:Real}\n    verts,edges,tris = py\"alpha_shape_3D($(coords),$(alpha))\"\n    return [indexshift(verts),indexshift(edges),indexshift(tris)]\nend\nfunction getspherepoints(cords::Matrix, radius::Real)\n\tpnts = [GeometryBasics.Point{3,Float64}(cords[i,:]) for i in 1:size(cords,1)] |> Observable\n\tspheres = GeometryBasics.Point{3,Float64}[]\n\tlift(pnts) do p\n\t\tfor i in 1:size(p,1)\n\t\t\tsp = GeometryBasics.decompose(GeometryBasics.Point{3,Float64},GeometryBasics.Sphere(p[i],radius),4) |> unique\n\t\t\tfor ii in 1:size(sp,1)\n\t\t\t\tpush!(spheres,sp[ii])\n\t\t\tend\n\t\tend\n\tend\n\treturn [[spheres[i].data...] for i in 1:size(spheres,1)] |> combinedims |> transpose |> collect\nend\nfunction linesegs(arr::AbstractArray{T,3}) where T<:AbstractFloat\n    new_arr::AbstractArray{Point3f0} = []\n    for i in 1:size(arr,1)\n        push!(new_arr, Makie.Point3f0(arr[i,1,:]))\n        push!(new_arr, Makie.Point3f0(arr[i,2,:]))\n    end\n    return new_arr |> combinedims |> transpose |> collect\nend\nstruc = retrievepdb(\"2vb1\")\nchn = struc[1][\"A\"] |> Observable\natms = collectatoms(struc, standardselector) |> Observable\ncords = @lift coordarray($atms)' |> collect\nfig = Figure(resolution = (800,600))\nlayout = fig[1,1] = GridLayout(10, 9)\nstrucname = struc.name[1:4]\nsc_scene = layout[1:10,1:6] = LScene(fig; show_axis = false)\nstructxt = layout[1,7:8] = Label(fig, text = \"Structure ID:  $(strucname)\", fontsize = 35)\nalpha1 = layout[5,7:9] = Slider(fig, range = 1.5:0.5:9.0, startvalue = 2.5)\nalphatxt1 = lift(alpha1.value) do s1; string(\"alpha = \", round(s1, sigdigits = 2)); end\nalphatext = layout[4,7:9] = Label(fig, text = alphatxt1, fontsize = 22)\nalphaval = alpha1.value\nradii1 = layout[7,7:9] = Slider(fig, range = 1.5:0.5:9.0, startvalue = 2.5)\nradiixt1 = lift(radii1.value) do s1; string(\"atom radius = \", round(s1, sigdigits = 2)); end\nradiitext = layout[6,7:9] = Label(fig, text = radiixt1, fontsize = 22)\nradiival = radii1.value;\nspnts = @lift getspherepoints($cords,$radiival)\nproteinshape = @lift let pnts = $spnts; getalphashape(pnts,$alphaval); end\nalphaverts = @lift $spnts[$(proteinshape)[1],:]\nalphaedges = @lift $spnts[$(proteinshape)[2],:] |> linesegs\nusing Meshes\nfunction surfacearea(coordinates, connectivity)\n    totalarea = 0.0\n    for i = 1:size(connectivity,1)\n        totalarea += measure(Ngon(Meshes.Point{3,Int64}.(coordinates[connectivity[i,1],:],\n                        coordinates[connectivity[i,2],:], coordinates[connectivity[i,3],:])...))\n    end\n    return totalarea\nend\nsurfarea = @lift surfacearea($spnts, $(proteinshape)[3])\nsurfatext = layout[2,7:9] = Label(fig, text = lift(X->string(\"surface area = \", round(Int64, X), \"  Å²\"), surfarea), fontsize = 22)\nlinesegments!(sc_scene, alphaedges, color = :gray, transparency = true)\nmeshscatter!(sc_scene, cords, markersize = 0.3, color = :blue)\nmeshscatter!(sc_scene, alphaverts, markersize = 0.3, color = :green)","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"(Image: alphashape)","category":"page"},{"location":"alphashape/#Alpha-shape-walkthrough","page":"Alpha Shape","title":"Alpha shape walkthrough","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"First are the regular imports.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"using BioMakie\nusing GLMakie\nusing GLMakie: Slider\nusing SplitApplyCombine\nusing GeometryBasics\nusing BioStructures","category":"page"},{"location":"alphashape/#Special-imports-(Python)","page":"Alpha Shape","title":"Special imports (Python)","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"SciPy and NumPy are required for this alpha shape algorithm. They need to be installed in your Conda/Python environment.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"using PyCall\nusing Conda\nscipy = pyimport(\"scipy\")\nnp = pyimport(\"numpy\")\ncollections = pyimport(\"collections\")","category":"page"},{"location":"alphashape/#Define-the-alpha-shape-algorithm.","page":"Alpha Shape","title":"Define the alpha shape algorithm.","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"py\"\"\"\n    from scipy.spatial import Delaunay\n    import numpy as np\n    from collections import defaultdict\n\n    def alpha_shape_3D(pos, alpha):\n        tetra = Delaunay(pos)\n        tetrapos = np.take(pos,tetra.simplices,axis=0)\n        normsq = np.sum(tetrapos**2,axis=2)[:,:,None]\n        ones = np.ones((tetrapos.shape[0],tetrapos.shape[1],1))\n        a = np.linalg.det(np.concatenate((tetrapos,ones),axis=2))\n        Dx = np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[1,2]],ones),axis=2))\n        Dy = -np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[0,2]],ones),axis=2))\n        Dz = np.linalg.det(np.concatenate((normsq,tetrapos[:,:,[0,1]],ones),axis=2))\n        c = np.linalg.det(np.concatenate((normsq,tetrapos),axis=2))\n        r = np.sqrt(Dx**2+Dy**2+Dz**2-4*a*c)/(2*np.abs(a))\n        tetras = tetra.simplices[r<alpha,:]\n        TriComb = np.array([(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)])\n        Triangles = tetras[:,TriComb].reshape(-1,3)\n        Triangles = np.sort(Triangles,axis=1)\n        TrianglesDict = defaultdict(int)\n        for tri in Triangles:\n            TrianglesDict[tuple(tri)] += 1\n        Triangles=np.array([tri for tri in TrianglesDict if TrianglesDict[tri] ==1])\n        EdgeComb=np.array([(0, 1), (0, 2), (1, 2)])\n        Edges=Triangles[:,EdgeComb].reshape(-1,2)\n        Edges=np.sort(Edges,axis=1)\n        Edges=np.unique(Edges,axis=0)\n        Vertices = np.unique(Edges)\n        return Vertices,Edges,Triangles\n    \"\"\"","category":"page"},{"location":"alphashape/#Define-julia-alpha-shape-function","page":"Alpha Shape","title":"Define julia alpha shape function","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Python is base 0 and Julia is base 1 so we first have to define a function to shift the indices.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"indexshift(idxs) = (idxs).+=1\nfunction getalphashape(coords::Matrix, alpha::T) where {T<:Real}\n    verts,edges,tris = py\"alpha_shape_3D($(coords),$(alpha))\"\n    return [indexshift(verts),indexshift(edges),indexshift(tris)]\nend","category":"page"},{"location":"alphashape/#Points-from-atomic-radii-spheres","page":"Alpha Shape","title":"Points from atomic radii spheres","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Define a function to get points from spheres at a given radius around coordinates and a function to get line segments from a set of coordinates.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"function getspherepoints(cords::Matrix, radius::Real)\n\tpnts = [GeometryBasics.Point{3,Float64}(cords[i,:]) for i in 1:size(cords,1)] |> Observable\n\tspheres = GeometryBasics.Point{3,Float64}[]\n\n\tlift(pnts) do p\n\t\tfor i in 1:size(p,1)\n\t\t\tsp = GeometryBasics.decompose(GeometryBasics.Point{3,Float64},GeometryBasics.Sphere(p[i],radius),4) |> unique\n\t\t\tfor ii in 1:size(sp,1)\n\t\t\t\tpush!(spheres,sp[ii])\n\t\t\tend\n\t\tend\n\tend\n\n\treturn [[spheres[i].data...] for i in 1:size(spheres,1)] |> combinedims |> transpose |> collect\nend\nfunction linesegs(arr::AbstractArray{T,3}) where T<:AbstractFloat\n    new_arr::AbstractArray{Point3f0} = []\n    for i in 1:size(arr,1)\n        push!(new_arr, Makie.Point3f0(arr[i,1,:]))\n        push!(new_arr, Makie.Point3f0(arr[i,2,:]))\n    end\n    return new_arr |> combinedims |> transpose |> collect\nend","category":"page"},{"location":"alphashape/#Load-a-structure-and-set-up-the-figure","page":"Alpha Shape","title":"Load a structure and set up the figure","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Load the structure with BioStructures.jl and get a coordinates Observable. Then set up the Figure and Layout.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"struc = retrievepdb(\"2vb1\")\nchn = struc[1][\"A\"] |> Observable\natms = collectatoms(struc, standardselector) |> Observable\ncords = @lift coordarray($atms)' |> collect\nfig = Figure(resolution = (800,600))\nlayout = fig[1,1] = GridLayout(10, 9)","category":"page"},{"location":"alphashape/#Add-text-and-interactive-elements","page":"Alpha Shape","title":"Add text and interactive elements","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"It can be helpful to run this line by line to see what is happening.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"strucname = struc.name[1:4]\nsc_scene = layout[1:10,1:6] = LScene(fig; show_axis = false)\nstructxt = layout[1,7:8] = Label(fig, text = \"Structure ID:  $(strucname)\", fontsize = 35)\nalpha1 = layout[5,7:9] = Slider(fig, range = 1.5:0.5:9.0, startvalue = 2.5)\nalphatxt1 = lift(alpha1.value) do s1; string(\"alpha = \", round(s1, sigdigits = 2)); end\nalphatext = layout[4,7:9] = Label(fig, text = alphatxt1, fontsize = 22)\nalphaval = alpha1.value\nradii1 = layout[7,7:9] = Slider(fig, range = 1.5:0.5:9.0, startvalue = 2.5)\nradiixt1 = lift(radii1.value) do s1; string(\"atom radius = \", round(s1, sigdigits = 2)); end\nradiitext = layout[6,7:9] = Label(fig, text = radiixt1, fontsize = 22)\nradiival = radii1.value;\nnothing #hide","category":"page"},{"location":"alphashape/#Alpha-shape","page":"Alpha Shape","title":"Alpha shape","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Lift the sphere points Observable to get the alpha shape vertices and edges. Our getalphashape function returns us both at once","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"spnts = @lift getspherepoints($cords,$radiival)\nproteinshape = @lift let pnts = $spnts; getalphashape(pnts,$alphaval); end\nalphaverts = @lift $spnts[$(proteinshape)[1],:]\nalphaedges = @lift $spnts[$(proteinshape)[2],:] |> linesegs","category":"page"},{"location":"alphashape/#Surface-area","page":"Alpha Shape","title":"Surface area","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Define a function to get the surface area of a set of coordinates and connectivity. The surface area changes when the alpha value or atom radius is changed.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"using Meshes\nfunction surfacearea(coordinates, connectivity)\n    totalarea = 0.0\n    for i = 1:size(connectivity,1)\n        totalarea += measure(Ngon(Meshes.Point3.(coordinates[connectivity[i,1],:],\n                        coordinates[connectivity[i,2],:], coordinates[connectivity[i,3],:])...))\n    end\n    return totalarea\nend\nsurfarea = @lift surfacearea($spnts, $(proteinshape)[3])\nsurfatext = layout[2,7:9] = Label(fig, text = lift(X->string(\"surface area = \", round(Int64, X), \"  Å²\"), surfarea), fontsize = 22)","category":"page"},{"location":"alphashape/#Plot-the-shape","page":"Alpha Shape","title":"Plot the shape","text":"","category":"section"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Finally, plot the mesh shape. Moving the sliders will update the plot. It is laggy, but it works to construct surfaces in real time. You may want to click on the slider rather than dragging it. Speed may be improved in the future.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"linesegments!(sc_scene, alphaedges, color = :gray, transparency = true)","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"To show where the atoms are run the following line.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"meshscatter!(sc_scene, cords, markersize = 0.3, color = :blue)","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"To show the alpha shape vertices run the following line.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"meshscatter!(sc_scene, alphaverts, markersize = 0.3, color = :green)","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"Save the figure as a png file.","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"save(\"alphashape.png\", fig)","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"","category":"page"},{"location":"alphashape/","page":"Alpha Shape","title":"Alpha Shape","text":"This page was generated using Literate.jl.","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"EditURL = \"https://github.com/BioJulia/BioMakie.jl/blob/dev/docs/src/dbinfo.md\"","category":"page"},{"location":"dbinfo/#Plotting-database-information","page":"Database Info","title":"Plotting database information","text":"","category":"section"},{"location":"dbinfo/#Copy-pastable-code-(almost,-you-need-your-OpenAI-API-key)","page":"Database Info","title":"Copy-pastable code (almost, you need your OpenAI API key)","text":"","category":"section"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"using BioMakie\nusing BioStructures\nusing GLMakie\nusing OrderedCollections\nusing JSON3\nusing OpenAI\nusing TextWrap\npdb = retrievepdb(\"2vb1\")\npdata = plottingdata(pdb)\ndat = getuniprotdata(\"P00698\"; include_refs = true)\ntxtbuffer = IOBuffer()\nuniprottxt = begin BioMakie.showsummary(txtbuffer, dat); String(take!(txtbuffer)) end\nfig = Figure(resolution = (900, 700))\nlayout = fig[1,1] = GridLayout(10, 9)\nplotstruc!(layout[1:10,1:5], pdata; resolution = (600, 700))\nENV[\"APIKEY\"] = \"{Your API key}\"    # Need to set your API key here!\nmodel = \"gpt-3.5-turbo\"\ntxt = Observable(\"\")\ntbox = Textbox(layout[4,6:9]; placeholder = \"Ask GPT about this protein...\", width = 350)\non(tbox.stored_string) do t\n        r = create_chat(\n        ENV[\"APIKEY\"],\n        model,\n        [Dict(\"role\" => \"user\", \"content\"=> t)]\n    )\n    txt[] = wrap(r.response[:choices][begin][:message][:content]; width = 50)\nend\nax = Axis(layout[1:3,6:9])\nGLMakie.text!(ax, uniprottxt, fontsize = 16, align = (:left, :top))\nxlims!(ax, (0, 1))\nylims!(ax, (-0.5, 0))\nhidespines!(ax)\nhideydecorations!(ax)\nhidexdecorations!(ax)\nax = Axis(layout[5:10,6:9])\nGLMakie.text!(ax, txt, fontsize = 16, align = (:left, :top))\nxlims!(ax, (0, 1))\nylims!(ax, (-0.5, 0))\nhidespines!(ax)\nhideydecorations!(ax)\nhidexdecorations!(ax)","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"(Image: dbinfo)","category":"page"},{"location":"dbinfo/#Database-information-explanation","page":"Database Info","title":"Database information explanation","text":"","category":"section"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"First are the regular imports.","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"using BioMakie\nusing BioStructures\nusing GLMakie\nusing OrderedCollections\nusing JSON3\nusing OpenAI\nusing TextWrap","category":"page"},{"location":"dbinfo/#Acquire-the-data","page":"Database Info","title":"Acquire the data","text":"","category":"section"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"Use BioStructures to retrieve a PDB file, then prepare the plotting data.","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"pdb = retrievepdb(\"2vb1\")\npdata = plottingdata(pdb)","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"Get the data from the web database using the associated accession ID and read it. Here I use the getuniprotdata function to get the data and save it to a file, then I gather the summary information using showsummary and utilize a IOBuffer to capture the string.","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"dat = getuniprotdata(\"P00698\"; include_refs = true)\ntxtbuffer = IOBuffer()\nuniprottxt = begin BioMakie.showsummary(txtbuffer, dat); String(take!(txtbuffer)) end","category":"page"},{"location":"dbinfo/#Set-up-the-figure-and-plot-the-structure","page":"Database Info","title":"Set up the figure and plot the structure","text":"","category":"section"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"fig = Figure(resolution = (900, 700))\nlayout = fig[1,1] = GridLayout(10, 9)\nplotstruc!(layout[1:10,1:5], pdata; resolution = (600, 700))","category":"page"},{"location":"dbinfo/#Set-up-the-text-box-to-prompt-GPT-3.5-turbo","page":"Database Info","title":"Set up the text box to prompt GPT-3.5-turbo","text":"","category":"section"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"First you need to acquire an API key for OpenAI. Then we can set up the text box using that. The on function is used to update the txt Observable with the response when you submit a prompt using the text box.","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"ENV[\"APIKEY\"] = \"{Your API key}\"\nmodel = \"gpt-3.5-turbo\"\ntxt = Observable(\"\")\ntbox = Textbox(layout[4,6:9]; placeholder = \"Ask GPT about this protein...\", width = 350)\non(tbox.stored_string) do t\n        r = create_chat(\n        ENV[\"APIKEY\"],\n        model,\n        [Dict(\"role\" => \"user\", \"content\"=> t)]\n    )\n    txt[] = wrap(r.response[:choices][begin][:message][:content]; width = 50)\nend","category":"page"},{"location":"dbinfo/#Plot-the-text","page":"Database Info","title":"Plot the text","text":"","category":"section"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"We basically plot the text onto a regular axis and hide the decorations, grid, etc.","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"ax = Axis(layout[1:3,6:9])\nGLMakie.text!(ax, uniprottxt, fontsize = 16, align = (:left, :top))\nxlims!(ax, (0, 1))\nylims!(ax, (-0.5, 0))\nhidespines!(ax)\nhideydecorations!(ax)\nhidexdecorations!(ax)\nax = Axis(layout[5:10,6:9])\nGLMakie.text!(ax, txt, fontsize = 16, align = (:left, :top))\nxlims!(ax, (0, 1))\nylims!(ax, (-0.5, 0))\nhidespines!(ax)\nhideydecorations!(ax)\nhidexdecorations!(ax)","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"","category":"page"},{"location":"dbinfo/","page":"Database Info","title":"Database Info","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/kool7d/BioMakie.jl/blob/dev/docs/src/index.md\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: biomakiename1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Status:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Latest release) (Image: License) (Image: Build Status)  (Image: BioJulia maintainer: kool7d)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs)","category":"page"},{"location":"#A-new-version-will-soon-be-released-(v0.2.3-v0.3.0)-which-introduces-many-new-features,-bugfixes,-and-breaking-changes.-Stay-tuned...","page":"Home","title":"A new version will soon be released (v0.2.3 -> v0.3.0) which introduces many new features, bugfixes, and breaking changes. Stay tuned...","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install BioMakie from the Julia package REPL, which can be accessed by pressing ] from the Julia REPL, then run add BioMakie.","category":"page"},{"location":"#Contributing-and-questions","page":"Home","title":"Contributing and questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Anyone can contribute to this package, by doing things like reporting bugs, fixing issues, improving performance, adding new features, and adding examples. Feel free to open an Issue or Pull Request, or communicate on the #biology or #makie channels of the Julia Slack.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides plotting functions for protein structures, multiple sequence alignments, and some other related plots like protein structure contact maps.  It also provides more complicated examples that show off additional functionality and interfaces.  The main plotting functions are plotstruc and plotmsa, along with their mutating versions, plotstruc! and plotmsa!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BioMakie\nusing GLMakie\nusing BioStructures\nstruc = retrievepdb(\"2vb1\") |> Observable\n## or\nstruc = read(\"2vb1.pdb\", BioStructures.PDB) |> Observable\n\nfig = Figure()\nplotstruc!(fig, struc; plottype = :ballandstick, gridposition = (1,1), atomcolors = aquacolors)\nplotstruc!(fig, struc; plottype = :covalent, gridposition = (1,2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: 2vb1crop)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To view a multiple sequence alignment, use the plotmsa function with a Pfam MSA or fasta file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FASTX\nreader = open(FASTX.FASTA.Reader, \"PF00062_full.fasta\")\nmsa = [reader...] |> Observable\nclose(reader)\n## or \nusing MIToS\nusing MIToS.MSA\nmsa = MIToS.MSA.read(\"pf00062.stockholm.gz\", Stockholm)\n\nfig = plotmsa(msa; colorscheme = :tableau_blue_green)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: msa)","category":"page"},{"location":"#Implemented-packages:","page":"Home","title":"Implemented packages:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Significant or full coverage: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"BioStructures.jl\nMIToS.jl\nFastaIO.jl\nFASTX.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some coverage:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MolecularGraph.jl\nProtoSyn.jl","category":"page"},{"location":"#Implemented-visualizations:","page":"Home","title":"Implemented visualizations:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Structures\nBall and stick, spacefilling, covalent representations\nSelections\nAlpha shapes\nMultiple sequence alignments\nGrid display\nSelections\nFrequency plot\nData acquisition from www.ebi.ac.uk and display ","category":"page"},{"location":"#To-Do:","page":"Home","title":"To Do:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Non-standard and modified amino acids\nConnect MSA and structure plot\nProtein dynamics\nBetter support for ligands and multiple chains\nDatabase web API interfaces\nWGLMakie support\nMore examples!","category":"page"},{"location":"API/#BioMakie-API","page":"API","title":"BioMakie API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [BioMakie]","category":"page"},{"location":"API/#BioMakie.UniProtData","page":"API","title":"BioMakie.UniProtData","text":"UniProtData::DataType\n\nA struct containing all the information from a UniProt entry.\n\nGeneral information\n\naccession id protinfo gene genesynonyms secondaryaccession sequence organism datainfo\n\nFeatures\n\nmoleculeprocessing domainsandsites structural ptm sequenceinformation mutagenesis variants topology other_features\n\nComments\n\nfunc catalyticactivity subunit subcellularlocation interaction tissuespecificity polymorphism allergen webresource similarity miscellaneous other_comments\n\nDatabase references (EMBL, PDB, etc.)\n\ndbrefs\n\n\n\n\n\n","category":"type"},{"location":"API/#BioMakie.atomcolors-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.atomcolors","text":"atomcolors( atoms )\n\nGet a Vector of colors for the atoms. To see all default element and amino acid colorschemes, use getbiocolors(). Keyword argument colors takes a Dict which maps element to color. (\"C\" => :red)\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\ncolors –- elecolors | Options - elecolors, aquacolors\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.atomradii-Union{Tuple{Vector{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.atomradii","text":"atomradii( atoms )\n\nCollect atom radii based on element for plotting.\n\nKeyword Arguments:\n\nradiustype –- :ballandstick | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.atomradius-Tuple{T} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.atomradius","text":"atomradius( atom )\n\nCollect atom radius based on element for plotting.\n\nKeyword Arguments:\n\nradiustype –- :ballandstick | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.atomsizes-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.atomsizes","text":"atomsizes( atms )\n\nGet a Vector of sizes for the atoms from a BioStructures.StructuralElementOrList.\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nradiustype –- :ballandstick | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.backbonebonds-Tuple{BioStructures.Chain}","page":"API","title":"BioMakie.backbonebonds","text":"backbonebonds( chn::BioStructures.Chain ) -> BitMatrix\n\nReturns a matrix of backbone bonds in chn, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nKeyword Arguments:\n\ncutoff –––––- 1.6\t\t# distance cutoff for bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.bondshape-Union{Tuple{Tuple{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.bondshape","text":"bondshape( twoatoms )\nbondshape( twopoints )\n\nReturns a (mesh) cylinder between two atoms or atomic coordinates.\n\nKeyword Arguments:\n\nbondwidth ––––––- 0.2\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.bondshapes-Tuple{BioStructures.Chain}","page":"API","title":"BioMakie.bondshapes","text":"bondshapes( structure )\nbondshapes( residues )\nbondshapes( coordinates )\nbondshapes( structure, bondmatrix )\nbondshapes( residues, bondmatrix )\nbondshapes( coordinates, bondmatrix )\n\nReturns a (mesh) cylinder between two atoms or points.\n\nKeyword Arguments:\n\nalgo ––––––––– :knowledgebased | :distance, :covalent\t# unless bondmatrix is given\ndistance ––––––– 1.9\t\t\t\t\t\t\t\t\t\t# unless bondmatrix is given\nbondwidth ––––––- 0.2\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.covalentbonds-Union{Tuple{Vector{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.covalentbonds","text":"covalentbonds( atms ) -> BitMatrix\n\nReturns a matrix of all bonds in atms, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nextradistance –– 0.14  # fudge factor for better inclusion\nH –––––––– true  # include bonds with hydrogen atoms\ndisulfides –––- false # include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.distancebonds-Union{Tuple{Vector{T}}, Tuple{T}} where T<:BioStructures.AbstractAtom","page":"API","title":"BioMakie.distancebonds","text":"distancebonds( atms ) -> BitMatrix\n\nReturns a matrix of all bonds in atms, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\ncutoff –––––- 1.9   # distance cutoff for bonds between heavy atoms\nhydrogencutoff –- 1.14  # distance cutoff for bonds with hydrogen atoms\nH –––––––– true  # include bonds with hydrogen atoms\ndisulfides –––- false # include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.firstlabel-Tuple{Function}","page":"API","title":"BioMakie.firstlabel","text":"firstlabel( inspectorfunc::Function )\n\nShow an example of the inspector label function looks like. The position p will not be available to this function, so it will be set to nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getbonds-Tuple{BioStructures.Chain, Vararg{Any}}","page":"API","title":"BioMakie.getbonds","text":"getbonds( chn::BioStructures.Chain, selectors... ) -> BitMatrix\ngetbonds( modl::BioStructures.Model, selectors... ) -> BitMatrix\ngetbonds( struc::BioStructures.ProteinStructure, selectors... ) -> BitMatrix\n\nReturns a matrix of all bonds in chn, where Mat[i,j] = 1 if atoms i and j are bonded. \n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nalgo ––––––- :knowledgebased \t# (:distance, :covalent) algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\ndisulfides –––- false\t\t\t\t# include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getbonds-Tuple{Vector{MIToS.PDB.PDBResidue}}","page":"API","title":"BioMakie.getbonds","text":"getbonds( residues ) -> BitMatrix\n\nReturns a matrix of all bonds in residues::Vector{MIToS.PDB.PDBResidue},  where Mat[i,j] = 1 if atoms i and j are bonded.\n\nKeyword Arguments:\n\nalgo ––––––- :knowledgebased \t# (:distance, :covalent) algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\ndisulfides –––- false\t\t\t\t# include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getbonds-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"BioMakie.getbonds","text":"getbonds( coords ) -> BitMatrix\n\nReturns a matrix of all bonds using a N x 3 coordinates matrix. Uses a plain cutoff distance with algo option :distance. This is not recommended as it can lead to incorrect results since different  atoms have different bond lengths and radii.\n\nKeyword Arguments:\n\nalgo ––––––- :distance \t\t\t# algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\ndisulfides –––- false\t\t\t\t# include disulfide bonds\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getinspectorlabel-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.getinspectorlabel","text":"getinspectorlabel( structure )\ngetinspectorlabel( residues )\ngetinspectorlabel( atom )\n\nGet the inspector label function for plotting a 'StructuralElementOrList'.\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.getuniprotdata-Tuple{Any}","page":"API","title":"BioMakie.getuniprotdata","text":"getuniprotdata(jsonfile; include_refs = false)\n\nReads a UniProt JSON file and returns a UniProtData struct.\n\nKeyword  Arguments:\n\ninclude_refs::Bool = false    Whether to include allthe database references (EMBL, PDB, etc.) in the struct.                               can be very large, so it is false by default.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.msavalues","page":"API","title":"BioMakie.msavalues","text":"msavalues( msa::AbstractMatrix, resdict::AbstractDict )::Matrix{Real}\n\nReturns a matrix of numbers according to the given dictionary, where keys are residue letters and values are numbers. This matrix is used as input for plotmsa for the heatmap colors of the residue positions. \n\nDefault values for residue letters are from Kidera Factor values.  From: Kenta Nakai, Akinori Kidera, Minoru Kanehisa, Cluster analysis of amino acid indices  for prediction of protein structure and function, Protein Engineering, Design and Selection,  Volume 2, Issue 2, July 1988, Pages 93–100, https://doi.org/10.1093/protein/2.2.93 \n\nkf 2 is Kidera Factor 2 (size/volume-related). The KF dictionary is in utils.jl, or you can look at the kideradict variable.\n\nKeyword Arguments:\n\nresdict –––- kideradict by default, alternatively give a Dict{String,Vector{Float}}\nkf –––––– 2 by default, alternatively give an integer from 1:10\n\n\n\n\n\n","category":"function"},{"location":"API/#BioMakie.plotmsa!-Union{Tuple{T}, Tuple{Makie.Figure, T}} where T<:Union{Vector{Tuple{String, String}}, Vector{FASTX.FASTA.Record}, MIToS.MSA.AbstractMultipleSequenceAlignment}","page":"API","title":"BioMakie.plotmsa!","text":"plotmsa!( fig, msa )\n\nPlot a multiple sequence alignment (MSA) into a Figure. \n\nExample\n\nfig = Figure(resolution = (1100, 400))\n\nplotmsa!( fig::Figure, msa::T; kwargs... ) where {T<:Union{MSA.AbstractMultipleSequenceAlignment,\n\t\t\t\t\t\t\t\t\t\t\t   Vector{Tuple{String,String}},\n\t\t\t\t\t\t\t\t\t\t\t   Vector{FASTX.FASTA.Record}}}\n\nKeyword Arguments:\n\nsheetsize ––- [40,20]\ngridposition – (1,1)\nmarkersize –– 12\ncolorscheme –- :buda\nmarkercolor –- :black\nxticklabelsize - 11\nyticklabelsize - 11\nresolution ––- (700,300)\nkwargs...   \t\t\t\t\t# forwarded to scatter plot\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plotmsa-Tuple{Any}","page":"API","title":"BioMakie.plotmsa","text":"plotmsa( msa )\nplotmsa( plotdata )\n\nPlot a multiple sequence alignment (MSA). Returns a Figure, or a Figure and Observables for interaction. \n\nExamples\n\nMIToS.Pfam.downloadpfam(\"PF00062\")\t# download PF00062 MSA\nmsa = MIToS.MSA.read(\"PF00062.stockholm.gz\", Stockholm, \n\t\t\t\t\tgeneratemapping =true, useidcoordinates=true)\n\nplotmsa( msa; kwargs... )\n\nKeyword Arguments:\n\nfigresolution ––- (1000,350)\t# because resolution applies to the MSA plot\nsheetsize ––––- [40,20]\ngridposition ––– (1,1:3)\ncolorscheme –––- :buda\nmarkersize –––– 12\nmarkercolor –––- :black\nxticklabelsize –– 11\nyticklabelsize –– 11\nkwargs...    \t\t\t\t\t\t# forwarded to scatter plot\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plotstruc!-Union{Tuple{T}, Tuple{Makie.Figure, T}} where T<:Union{Vector{MIToS.PDB.PDBAtom}, Vector{MIToS.PDB.PDBResidue}, BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.plotstruc!","text":"plotstruc!( fig, structure )\nplotstruc!( gridposition, structure )\nplotstruc!( fig, plotdata )\nplotstruc!( gridposition, plotdata )\n\nPlot a protein structure(/chain/residues/atoms) into a Figure. \n\nExamples\n\nfig = Figure()\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"2vb1\")\nstruc = MIToS.PDB.read(pdbfile, PDBML) |> Observable\nstrucplot = plotstruc!(fig, struc)\n\nchain_A = @residues struc model \"1\" chain \"A\" group \"ATOM\" residue All\nstrucplot = plotstruc!(fig, chain_A)\n\nchnatms = @atoms struc model \"1\" chain \"A\" group \"ATOM\" residue All atom All\nstrucplot = plotstruc!(fig, chnatms)\n-------------------------\nusing BioStructures\n\nstruc = retrievepdb(\"2vb1\", dir = \"data/\") |> Observable\nstrucplot = plotstruc!(fig, struc)\n\nstruc = read(\"data/2vb1_mutant1.pdb\", BioStructures.PDB) |> Observable\nstrucplot = plotstruc!(fig, struc)\n\nchain_A = retrievepdb(\"2vb1\", dir = \"data/\")[\"A\"] |> Observable\nstrucplot = plotstruc!(fig, chain_A)\n\nKeyword Arguments:\n\nresolution ––- (600,600)\ngridposition –- (1,1)  # if an MSA is already plotted, (2,1:3) works well\nplottype –––- :ballandstick, :covalent, or :spacefilling\natomcolors ––- elecolors, others in getbiocolors(), or provide a Dict like: \"N\" => :blue\nmarkersize ––- 0.0\nmarkerscale –– 1.0\nbondtype –––- :knowledgebased, :covalent, or :distance\ndistance –––- 1.9  # distance cutoff for covalent bonds\ninspectorlabel - :default, or define your own function like: (self, i, p) -> \"atom: ... coords: ...\"\nwater ––––– false  # show water molecules\nkwargs... ––– keyword arguments passed to the atom meshscatter\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plotstruc-Tuple{Any}","page":"API","title":"BioMakie.plotstruc","text":"plotstruc( structure )\nplotstruc( residues )\nplotstruc( plotdata )\n\nCreate and return a Makie Figure for a protein structural element. \n\nExamples\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"2vb1\")\nstruc = MIToS.PDB.read(pdbfile, PDBML) |> Observable\nstrucplot = plotstruc(struc)\n\nchain_A = @residues struc model \"1\" chain \"A\" group \"ATOM\" residue All\nstrucplot = plotstruc(chain_A)\n\nchnatms = @atoms struc model \"1\" chain \"A\" group \"ATOM\" residue All atom All\nstrucplot = plotstruc(chnatms)\n-------------------------\nusing BioStructures\n\nstruc = retrievepdb(\"2vb1\", dir = \"data/\") |> Observable\nstrucplot = plotstruc(struc)\n\nstruc = read(\"data/2vb1_mutant1.pdb\", BioStructures.PDB) |> Observable\nstrucplot = plotstruc(struc)\n\nchain_A = retrievepdb(\"2hhb\", dir = \"data/\")[\"A\"] |> Observable\nstrucplot = plotstruc(chain_A)\n\nKeyword Arguments:\n\nfigresolution – (600,600)    # because resolution applies to the plot\nresolution ––- (600,600)\ngridposition –- (1,1)        # if an MSA is already plotted, (2,1:3) works well\nplottype –––- :ballandstick, :covalent, or :spacefilling\natomcolors ––- elecolors, others in getbiocolors(), or provide a Dict like: \"N\" => :blue\nmarkersize ––- 0.0\nmarkerscale –– 1.0\nbondtype –––- :knowledgebased, :covalent, or :distance\ndistance –––- 1.9  # distance cutoff for covalent bonds\ninspectorlabel - :default, or define your own function like: (self, i, p) -> \"atom: ... coords: ...\"\nwater ––––– false  # show water molecules\nkwargs... ––– keyword arguments passed to the atom meshscatter\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plottingdata-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.plottingdata","text":"plottingdata( structure )\nplottingdata( residues )\nplottingdata( atoms )\n\nThis function returns an OrderedDict of the main data used for plotting.  This function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom. By default the kwarg 'water' is set to false, so water molecules are not included.\n\nReturns:\n\nOrderedDict(:atoms => ..., \n            :coords => ..., \n            :colors => ...,\n            :sizes => ...,\n            :bonds => ...)\n\nKeyword Arguments:\n\ncolors –––- elecolors      | Options - elecolors, aquacolors, shapelycolors, maecolors\nradiustype –- :ballandstick  | Options - :cov, :covalent, :vdw, :vanderwaals, :bas, :ballandstick, :spacefilling\nwater –––– false          | Options - true, false\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.plottingdata-Tuple{MIToS.MSA.AbstractMultipleSequenceAlignment}","page":"API","title":"BioMakie.plottingdata","text":"plottingdata( msa )\n\nCollects data for plotting (residue string matrix, matrix heatmap values,  x labels, and y labels) from a multiple sequence alignment (MSA) object. \n\nThe MSA object can be a: \n\nAbstractMultipleSequenceAlignment from MIToS.MSA, \nvector of tuples 'Vector{Tuple{String,String}}' from FastaIO, \nvector of FASTA records 'Vector{FASTX.FASTA.Record}' from FASTX.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.rescolors-Tuple{BioStructures.StructuralElementOrList}","page":"API","title":"BioMakie.rescolors","text":"rescolors( residues )\n\nGet a Vector of colors for the atoms. To see all default element and amino acid colorschemes, use getbiocolors(). Keyword argument colors takes a Dict which maps residue to color. (\"C\" => :red)\n\nThis function uses 'MIToS.PDB.bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\ncolors –- elecolors | Options - elecolors, aquacolors, shapelycolors, maecolors\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.showuniprotdata-Tuple{Any, Any}","page":"API","title":"BioMakie.showuniprotdata","text":"showuniprotdata(pdata)\n\nPrints some of the most important information from a UniProtData object.\n\n\n\n\n\n","category":"method"},{"location":"API/#BioMakie.sidechainbonds-Tuple{BioStructures.AbstractResidue, Vararg{Any}}","page":"API","title":"BioMakie.sidechainbonds","text":"sidechainbonds( res::BioStructures.AbstractResidue, selectors... ) -> BitMatrix\n\nReturns a matrix of sidechain bonds in res, where Mat[i,j] = 1 if atoms i and j are bonded.\n\nThis function uses 'bestoccupancy' or 'defaultatom' to ensure only one position per atom.\n\nKeyword Arguments:\n\nalgo ––––––- :knowledgebased \t# (:distance, :covalent) algorithm to find bonds\nH –––––––– true\t\t\t\t# include bonds with hydrogen atoms\ncutoff –––––- 1.9\t\t\t\t# distance cutoff for bonds between heavy atoms\nextradistance –– 0.14\t\t\t\t# fudge factor for better inclusion\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap!-Tuple{Makie.Figure, BioStructures.ContactMap}","page":"API","title":"MakieCore.heatmap!","text":"heatmap!( fig, cmap; kwargs... )\n\nPlot a BioStructures contact map.\n\nExample\n\nfig = Figure()\n\nusing BioStructures\n\nstruc = retrievepdb(\"1IVO\")[1]\ncbetas_A = collectatoms(struc[\"A\"], cbetaselector)\ncbetas_B = collectatoms(struc[\"B\"], cbetaselector)\ncmap = ContactMap(cbetas_A, cbetas_B)\nheatmap!(fig, cmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :ice\nkwargs... ––––––– Keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap!-Tuple{Makie.Figure, BioStructures.DistanceMap}","page":"API","title":"MakieCore.heatmap!","text":"heatmap( dmap; kwargs... )\n\nPlot a BioStructures distance map.\n\nExample\n\nusing BioStructures\n\nstruc = retrievepdb(\"1IVO\")[1]\ncbetas_A = collectatoms(struc[\"A\"], cbetaselector)\ncbetas_B = collectatoms(struc[\"B\"], cbetaselector)\ndmap = DistanceMap(cbetas_A, cbetas_B)\nheatmap(dmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :viridis\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap!-Tuple{Makie.Figure, NamedArrays.NamedMatrix{Bool, PairwiseListMatrices.PairwiseListMatrix{Bool, false, Vector{Bool}}, Tuple{OrderedCollections.OrderedDict{String, Int64}, OrderedCollections.OrderedDict{String, Int64}}}}","page":"API","title":"MakieCore.heatmap!","text":"heatmap!( fig, cmap; kwargs... )\n\nPlot a MIToS contact map.\n\nExample:\n\nfig = Figure()\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"1IVO\", format=PDBFile)\nresidues_1ivo = read(pdbfile, PDBFile)\npdb = @residues residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All\ncmap = contact(pdb, 8.0, criteria=\"CB\")\n\nheatmap!(fig, cmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :ice\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap!-Tuple{Makie.Figure, NamedArrays.NamedMatrix{Float64, PairwiseListMatrices.PairwiseListMatrix{Float64, false, Vector{Float64}}, Tuple{OrderedCollections.OrderedDict{String, Int64}, OrderedCollections.OrderedDict{String, Int64}}}}","page":"API","title":"MakieCore.heatmap!","text":"heatmap!( fig, dmap; kwargs... )\n\nPlot a MIToS distance map.\n\nExample\n\nfig = Figure()\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"1IVO\", format=PDBFile)\nresidues_1ivo = read(pdbfile, PDBFile)\npdb = @residues residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All\ndmap = MIToS.PDB.distance(pdb, criteria=\"All\")\n\nheatmap!(fig, dmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :viridis\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap-Tuple{BioStructures.ContactMap}","page":"API","title":"MakieCore.heatmap","text":"heatmap( cmap; kwargs... )\n\nPlot a BioStructures contact map.\n\nExample\n\nusing BioStructures\n\nstruc = retrievepdb(\"1IVO\")[1]\ncbetas_A = collectatoms(struc[\"A\"], cbetaselector)\ncbetas_B = collectatoms(struc[\"B\"], cbetaselector)\ncmap = ContactMap(cbetas_A, cbetas_B)\nheatmap(cmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :ice\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap-Tuple{BioStructures.DistanceMap}","page":"API","title":"MakieCore.heatmap","text":"heatmap( dmap; kwargs... )\n\nPlot a BioStructures distance map.\n\nExample\n\nusing BioStructures\n\nstruc = retrievepdb(\"1IVO\")[1]\ncbetas_A = collectatoms(struc[\"A\"], cbetaselector)\ncbetas_B = collectatoms(struc[\"B\"], cbetaselector)\ndmap = DistanceMap(cbetas_A, cbetas_B)\nheatmap(dmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :viridis\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap-Tuple{NamedArrays.NamedMatrix{Bool, PairwiseListMatrices.PairwiseListMatrix{Bool, false, Vector{Bool}}, Tuple{OrderedCollections.OrderedDict{String, Int64}, OrderedCollections.OrderedDict{String, Int64}}}}","page":"API","title":"MakieCore.heatmap","text":"heatmap( cmap; kwargs... )\n\nPlot a MIToS contact map.\n\nExample:\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"1IVO\", format=PDBFile)\nresidues_1ivo = read(pdbfile, PDBFile)\npdb = @residues residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All\ncmap = contact(pdb, 8.0, criteria=\"CB\")\n\nheatmap(cmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- Colormap to use\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"},{"location":"API/#MakieCore.heatmap-Tuple{NamedArrays.NamedMatrix{Float64, PairwiseListMatrices.PairwiseListMatrix{Float64, false, Vector{Float64}}, Tuple{OrderedCollections.OrderedDict{String, Int64}, OrderedCollections.OrderedDict{String, Int64}}}}","page":"API","title":"MakieCore.heatmap","text":"heatmap( dmap; kwargs... )\n\nPlot a MIToS distance map.\n\nExample\n\nusing MIToS.PDB\n\npdbfile = MIToS.PDB.downloadpdb(\"1IVO\", format=PDBFile)\nresidues_1ivo = read(pdbfile, PDBFile)\npdb = @residues residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All\ndmap = MIToS.PDB.distance(pdb, criteria=\"All\")\n\nheatmap(dmap)\n\nKeyword Arguments:\n\nxlabel ––––––––- \"Item 2\"\nylabel ––––––––- \"Item 1\"\ncolormap –––––––- :viridis\nkwargs... ––––––– additional keyword arguments to pass to heatmap\n\n\n\n\n\n","category":"method"}]
}
